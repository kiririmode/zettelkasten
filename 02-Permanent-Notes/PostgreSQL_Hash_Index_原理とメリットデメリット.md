# PostgreSQL Hash Index：原理とメリット・デメリット

## 概要

PostgreSQL Hash Indexは、ハッシュテーブルのデータ構造を利用したインデックス方式であり、等価検索（=）に特化した高速検索を提供します。B-treeインデックスが広く使われる中で、Hash Indexは特定の用途において性能優位性を発揮する一方で、制約も多い特殊なインデックスです。本ノートでは、Hash Indexの技術的原理、B-treeとの比較、実用上のメリット・デメリットについて詳述します。

## Hash Indexの基本原理

### ハッシュテーブルのデータ構造

Hash Indexは、インデックス対象となる値にハッシュ関数を適用し、計算されたハッシュ値を基にデータの格納位置（バケット）を決定します。この仕組みにより、理論的にはO(1)の時間計算量で検索が可能となります。

PostgreSQLのHash Indexでは、以下の構造を持ちます：

- **メタページ**: インデックス全体の構造情報とハッシュ関数のパラメータを格納
- **バケットページ**: 実際のハッシュ値とタプルIDのペアを格納する領域
- **オーバーフローページ**: ハッシュ衝突が発生した場合の追加データ格納領域

### ハッシュ衝突の処理

異なる値が同じハッシュ値を生成する「ハッシュ衝突」が発生した場合、PostgreSQLでは連鎖法（チェイン法）を採用しています。同じバケットに複数の値が格納される際は、オーバーフローページを連鎖的に作成し、線形探査によって目的の値を探索します。

## Hash IndexとB-tree Indexの比較

### 検索性能の違い

**Hash Index:**
- 等価検索（WHERE column = value）においてO(1)の理論的性能
- 範囲検索やソート処理には対応不可
- ハッシュ衝突が多発するとO(n)に劣化する可能性

**B-tree Index:**
- 等価検索、範囲検索、ソート処理すべてに対応
- 検索時間計算量はO(log n)で安定
- PostgreSQLのデフォルトインデックス方式

### ストレージサイズとメモリ効率

Hash Indexは、ハッシュ値（通常4バイト）のみを格納するため、文字列や数値型のカラムにおいてB-treeよりもコンパクトなインデックスを構築できる場合があります。特に、長い文字列データや高精度数値データでは、インデックスサイズの削減効果が顕著に現れます。

## Hash Indexのメリット

### 1. 等価検索での高速性能

Hash Indexは等価検索において、B-treeインデックスを上回る性能を発揮する場合があります。特に、以下の条件が揃った場合に優位性が明確になります：

- **大量データでの単一値検索**: 数百万～数千万行のテーブルでの特定値検索
- **選択性の高いカラム**: カーディナリティが高く、各値の出現頻度が均等
- **複雑なJOIN処理**: ハッシュ結合での内部処理最適化

### 2. インデックスサイズの効率化

長い文字列や高精度数値をインデックス対象とする場合、ハッシュ値による固定長格納により、B-treeと比較してインデックスサイズを30-50%削減できる事例が報告されています。これにより、メモリ使用量の削減とキャッシュ効率の向上が期待できます。

### 3. 並列処理での優位性

PostgreSQL 10以降、Hash Indexは並列スキャンに対応しており、大規模データセットでの並列検索処理において、B-treeよりも効率的な負荷分散が可能となります。

## Hash Indexのデメリット

### 1. 機能的制約

Hash Indexは以下の重要な制約があります：

- **範囲検索不可**: WHERE句での不等号演算子（<, >, <=, >=）に対応不可
- **ORDER BY不可**: ソート処理に利用不可
- **LIKE検索不可**: 前方一致や部分一致検索に対応不可
- **NULL値処理**: NULL値のインデックス格納が不可

### 2. レプリケーションとバックアップの制約

PostgreSQL 10より前のバージョンでは、Hash IndexはWAL（Write Ahead Log）に記録されないため、以下の問題が発生していました：

- **ストリーミングレプリケーション不可**: スタンバイサーバーでのHash Index復元不可
- **Point-in-timeリカバリ不可**: バックアップからの復旧時にインデックス再構築が必要

PostgreSQL 10以降はWALログ対応により改善されましたが、古いバージョンを使用する環境では重大な制約となります。

### 3. ハッシュ衝突によるパフォーマンス劣化

データの分布やハッシュ関数の特性により、特定のバケットに偏った格納が発生すると、検索性能がO(n)まで劣化する可能性があります。特に、以下の条件で性能劣化リスクが高まります：

- **低カーディナリティデータ**: 同一値の重複が多い
- **偏った分布**: 特定の値域に集中したデータ
- **ハッシュ関数の品質**: 使用するハッシュ関数がデータ特性に適合しない

## 実用上の運用指針

### Hash Index適用の判断基準

Hash Indexの導入を検討すべき場面：

1. **主要な検索パターンが等価検索のみ**: WHERE column = value形式がクエリの90%以上
2. **高いカーディナリティ**: インデックス対象カラムの重複値が少ない
3. **大規模データセット**: 数百万行以上のテーブルでの検索最適化
4. **JOIN処理の最適化**: ハッシュ結合が頻繁に発生する

### 避けるべき場面

以下の条件に該当する場合、B-treeインデックスの選択が推奨されます：

- 範囲検索やソート処理が必要
- レプリケーション環境での運用
- インデックス対象データに偏りがある
- PostgreSQL 9.6以前のバージョンを使用

## 批判的視点・反証

### Hash Indexの実用性への疑問

PostgreSQLコミュニティにおいて、Hash Indexの実用性については以下の議論があります：

**性能優位性の限定性**: 現代のハードウェア環境では、B-treeインデックスの性能が大幅に向上しており、Hash Indexの理論的優位性が実際の運用で体感できる場面は限定的という指摘があります。

**運用コストの増大**: Hash IndexとB-treeインデックスの併用により、インデックス管理の複雑性が増大し、長期的な運用コストが性能向上効果を上回る可能性があります。

**PostgreSQL最適化の方向性**: PostgreSQLの開発方針として、B-treeインデックスの最適化に注力しており、Hash Indexへの投資は相対的に少ないことから、将来的な性能格差拡大への懸念があります。

### 代替手段の検討

Hash Indexの導入前に、以下の代替アプローチを検討することが推奨されます：

- **パーティショニング**: テーブル分割による検索範囲の限定
- **部分インデックス**: 条件付きB-treeインデックスによる選択的インデックス
- **マテリアライズドビュー**: 事前集計による検索負荷の軽減

## 関連ノート・リンク

- [[B-tree Index最適化戦略]]
- [[PostgreSQL インデックス選択指針]]
- [[データベースパフォーマンスチューニング基礎]]
- [[ハッシュテーブルアルゴリズムの基礎]]

#database #postgresql #performance #database/index #design/database
