# Feature-Sliced Design

## 定義

Feature-Sliced Design（FSD）は、フロントエンドプロジェクトのためのアーキテクチャ手法である。技術的な層ではなくビジネス機能を中心にコードを組織化し、明示的なビジネスロジックと機能駆動開発を重視する。単純に言えば、コードの組織化に関するルールと慣例の集合体である。

## 核となる構造概念

FSDアーキテクチャは3つの主要な構造概念で構築される：

### 1. レイヤー（Layers）
アプリケーションコンポーネントを異なる階層に組織化する最上位フォルダ。全てのFSDプロジェクトで標準化されている。現在7つのレイヤーが存在する（上位から下位へ）：

- **App**: アプリの実行に必要な全て（ルーティング、エントリーポイント、グローバルスタイル、プロバイダー）
- **Processes**（非推奨）: 複雑なページ間シナリオ
- **Pages**: 完全なページまたはネストされたルーティングにおけるページの大部分
- **Widgets**: 大きな自己完結型の機能またはUIチャンク、通常は完全なユースケースを提供
- **Features**: 製品機能全体の再利用可能な実装、ユーザーにビジネス価値をもたらす行動
- **Entities**: プロジェクトが扱うビジネスエンティティ（ユーザー、製品など）
- **Shared**: 再利用可能な機能、特にプロジェクト/ビジネス固有でない場合

### 2. スライス（Slices）
レイヤー内のフォルダで、ドメイン（ページの場合はページ別）でレイヤーを分割する。論理的に関連するモジュールを近くに保つことで、コードベースのナビゲーションを容易にする。

### 3. セグメント（Segments）
スライス（またはレイヤー）を技術的目的（コードが何のためにあるか）で分割するフォルダ。

## アーキテクチャルール

### 階層インポートルール
レイヤーの重要な特徴は、あるレイヤーのモジュールは、厳密に下位のレイヤーからのモジュールのみを知り、インポートできることである。

- **下位レイヤー**（例：shared）は上位または同位のレイヤーについて何も知らない
- **上位レイヤー**（例：entities）は下位のすべてのレイヤーを使用できる
- 同一レイヤー内のスライス間での使用は禁止（高凝集・低結合の実現）

### インポートフローの方向
```
App → Pages → Widgets → Features → Entities → Shared
```

## 詳細なレイヤー解説

### Pages レイヤー
- アプリの各ページのルートコンポーネントを含む
- 主に構成要素で、ロジックはほとんどない
- 可能な限り「薄く」あるべきで、主に独立して動作するWidgetで構成される

### Widgets レイヤー
- 完全なユースケースを提供する大きな自己完結型のUIチャンク
- 小さな再利用可能コンポーネント、UIキット要素、Features、Entitiesを組み合わせる
- ページで使用されるスタンドアロンUIコンポーネント

### Features レイヤー
- ユーザーにビジネス価値をもたらす製品機能の再利用可能な実装
- ユーザーシナリオと機能を扱う（いいね、レビュー投稿、製品評価など）
- ショッピングカートへのアイテム追加/削除、合計金額と割引の計算など

### Entities レイヤー
- プロジェクトが扱うビジネスエンティティ
- ユーザー、製品、ブログ記事などのプロジェクトのデータエンティティ
- ビジネスロジックの核となる概念

### Shared レイヤー
- ビジネスロジックに縛られない再利用可能なコンポーネントとユーティリティ
- UIキット、axios設定、アプリケーション設定、ヘルパーなど
- プロジェクト/ビジネス固有でない機能

## 利点

### 開発効率の向上
- **コードの発見しやすさ**: 標準化された構造により新規メンバーも理解しやすい
- **スケーラビリティ**: 大規模Reactアプリケーションの自然な成長に対応
- **リファクタリングの簡素化**: 各コンポーネントが明確な目的と予測可能な依存関係を持つ

### 保守性の向上
- **バグの分離**: 機能中心の構造により問題を特定しやすい
- **新機能の展開**: 既存コードへの影響を最小限に抑制
- **回帰の可能性低減**: アーキテクチャの明確性により保守性が向上

## 適用場面

### 推奨される場合
- フロントエンド開発（Web、モバイル、デスクトップのUI）
- 複数チームでの共同開発
- 大規模プロジェクトまたは急速に成長するアプリケーション
- 既存アーキテクチャが開発効率を阻害している場合

### 制約
- プログラミング言語、UIフレームワーク、状態管理ツールに制限なし
- プロジェクトやチームサイズに制限なし

## ツールチェーン

FSDは規約の集合だけでなく、ツールチェーンも提供：
- **Linter**: プロジェクトアーキテクチャのチェック
- **CLI**: フォルダジェネレーター
- **IDE統合**: 開発環境での支援
- **豊富な実例ライブラリ**: 学習とベストプラクティス

## 批判的視点

### 学習コストの問題
- 複雑なアーキテクチャ理解が必要で初心者には負担
- 小規模プロジェクトには過剰設計の可能性
- チーム全体での理解統一が必要

### 柔軟性の制約
- 厳格な階層ルールによる開発の制約
- 既存プロジェクトへの適用時の大幅なリファクタリング必要
- ビジネス要件の変化に対する適応の複雑さ

### 実装の複雑性
- 適切なレイヤー分割の判断が困難
- 依存関係の管理が複雑化する可能性
- 小さな変更でも複数レイヤーへの影響

## 関連概念

- [[アーキテクチャパターン]]
- [[React開発手法]]
- [[モジュラー設計]]
- [[Vibe Coding]]

#frontend #architecture #react #fsd #design-pattern